use std::collections::HashMap;
use crate::bus::Bus;
//use crate::cpu::Instructions;
use crate::cpu::instructions;

pub struct CPU{
    pub pc: u32,
    pb: u32, // program break location
    pub sp: u32,
    pub r: [u32; 32],//registers
    //pub status: u8,
    bus: Bus,
    reg: HashMap<u32, fn(&mut CPU, (usize, usize, usize, usize))>, // 5 + 5 + 5 + 5
    imm: HashMap<u32, fn(&mut CPU, (usize, usize, u16))>, // 5 + 5 + 16
    jmp: HashMap<u32, fn(&mut CPU, u32)> // 6 + 26
}

impl CPU{
    // size indicates program size(lines of code)
    pub fn init(size: u32) -> CPU{
        let r: HashMap<u32, fn(&mut CPU, (usize, usize, usize, usize))> = HashMap::from([
            (0b100000, instructions::add as fn(&mut CPU, (usize, usize, usize, usize)))
        ]);
        let i: HashMap<u32, fn(&mut CPU, (usize, usize, u16))> = HashMap::from([]);
        let j: HashMap<u32, fn(&mut CPU, u32)> = HashMap::from([]);
        CPU{pc:0, pb: size, sp:0xffff-1, r: [0; 32], bus: Bus::init(), reg: r, imm: i, jmp: j}
    }
    pub fn write_bus(&mut self, addr: u32, val:u32){
        self.bus.write(addr, val);
    }
    pub fn exec_inst(&mut self){
        let bytecode = self.bus.read(self.pc);
        let op = bytecode >> 26; // most sig 6 bits are op code
        match op {
            0 => {
                // first 6 bits, to get the function
                let func = bytecode & 0x3F;
                // grab from arithmetic instructions and dereference whats inside
                // the option
                let inst = self.reg.get(&func).map(|x| *x);
                // grab data from register!
                let rs = ((bytecode >> 21) & 0x1F) as usize;
                let rd = ((bytecode >> 16) & 0x1F) as usize;
                let rt = ((bytecode >> 11) & 0x1F) as usize;
                let shamt = ((bytecode >> 6) & 0x1F) as usize;
                // TODO: error handler/exception handler it. this shouldn't happen though
                // because it would run into issue with the loader
                // left in as debugging for func testing though
                match inst {
                    Some(inst) => inst(&mut self, (rs, rd, rt, shamt)),
                    None => {
                        println!("invalid op!");
                    }
                }
            },
            1..=7 => {
                let inst = self.jmp.get(&op).map(|x| *x);
                // i think this works. This should be first 26 bits.
                let addr = bytecode & 0x3FFFFFF;
                match inst {
                    Some(inst) => inst(&mut self, addr),
                    None => println!("invalid op!")
                }
            },// jmp,
            8..=43 => {
                let rs = ((bytecode >> 21) & 0x1F) as usize;
                let rd = ((bytecode >> 16) & 0x1F) as usize;
                let imm = ((bytecode >> 6) & 0xFFFF) as u16;
                let inst = self.imm.get(&op).map(|x| *x);

                match inst{
                    Some(inst) => inst(&mut self, (rs, rd, imm)),
                    None => println!("invalid op!"),
                }
            },//imm
            _ => {println!("{}: Not a valid op!", op)}
        }
    }
}

mod tests{
    use super::*;

    #[test]
    fn test_reg(){
        let mut c = CPU::init(1);
        c.write_bus(c.pc, 0b000000000010000000010100000);
        c.r[0] = 1u32;
        c.r[2] = 2u32;
        c.exec_inst();
        assert!(c.r[1] == 3);
    }
}
